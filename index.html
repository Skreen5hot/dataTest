<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure PWA (BYOT) PoC</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; max-width: 600px; margin: auto; }
        div { margin-bottom: 15px; border: 1px solid #ddd; padding: 15px; border-radius: 8px; }
        input[type="password"], input[type="text"] { width: 95%; padding: 10px; font-size: 16px; margin-bottom: 10px; }
        button { padding: 12px 18px; font-size: 16px; cursor: pointer; background: #0366d6; color: white; border: none; border-radius: 6px; }
        button:hover { background: #0056b3; }
        button.danger { background: #d73a49; }
        button.danger:hover { background: #b02a37; }
        button.secondary { background: #6a737d; }
        pre { background: #f6f8fa; padding: 15px; border-radius: 6px; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; }
        .hidden { display: none; }
        /* File Explorer Styles */
        #file-explorer { list-style: none; padding: 0; }
        #file-explorer li { font-size: 18px; padding: 8px; border-radius: 5px; cursor: pointer; }
        #file-explorer li:hover { background: #f6f8fa; }
        #file-explorer li a { text-decoration: none; color: #0366d6; }
        #file-content { max-height: 400px; overflow-y: auto; }
    </style>
</head>
<body>

    <h1>Secure PWA PoC (User Token)</h1>
    <p>Status: <b id="status">Initializing...</b></p>

    <div id="view-setup">
        <h3>Setup Connection</h3>
        <p>
            Please generate a <a href="https://github.com/settings/tokens?type=beta" target="_blank">Fine-grained Personal Access Token</a>
            on GitHub. Grant it **"Read & Write"** access to **"Contents"** for your single repository.
        </p>
        <form id="form-setup">
            <label for="setup-repo">Repository Path (e.g., owner/repo)</label>
            <input type="text" id="setup-repo" placeholder="your-username/your-repo-name" required>

            <label for="setup-token">GitHub Personal Access Token (github_pat_...)</label>
            <input type="text" id="setup-token" placeholder="github_pat_..." required>
            
            <label for="setup-password">Create a Master Password (to encrypt this token)</label>
            <input type="password" id="setup-password" placeholder="Your new master password" required>
            
            <button type="submit">Encrypt and Save</button>
        </form>
    </div>

    <div id="view-unlock" class="hidden">
        <h3>Unlock Session</h3>
        <p>Welcome back! Please enter your master password to decrypt your GitHub connection.</p>
        <form id="form-unlock">
            <input type="password" id="unlock-password" placeholder="Your master password" required>
            <button type="submit">Unlock</button>
        </form>
    </div>

    <div id="view-loggedin" class="hidden">
        <h3>Session Unlocked</h3>
        <p>Session token is loaded in memory.</p>
        <button id="btn-logout" class="danger">Log Out & Clear Token</button>

        <div id="explorer-view">
            <h3>Repository Browser</h3>
            <button id="btn-back" class="secondary">Up One Level</button>
            <h4 style="margin-bottom: 5px;">Current Path: <code id="current-path">/</code></h4>
            
            <ul id="file-explorer"></ul>
            
            <pre id="file-content" class="hidden"></pre>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const DB_NAME = 'pwa-secure-db';
        const DB_STORE_NAME = 'settings';
        const DB_TOKEN_KEY = 'github_token_data';
        
        // --- 2. GLOBAL STATE ---
        let db; // Our IndexedDB instance
        let sessionAccessToken = null; // Our IN-MEMORY token
        let sessionRepoPath = null; // Our IN-MEMORY repo path
        let currentPath = ''; // The path we are currently viewing
        
        // --- 3. UI HELPERS ---
        const statusEl = document.getElementById('status');
        // Cache more UI elements
        const fileExplorerEl = document.getElementById('file-explorer');
        const fileContentEl = document.getElementById('file-content');
        const currentPathEl = document.getElementById('current-path');
        const views = {
            setup: document.getElementById('view-setup'),
            unlock: document.getElementById('view-unlock'),
            loggedin: document.getElementById('view-loggedin')
        };
        
        function showView(viewName) {
            Object.values(views).forEach(v => v.classList.add('hidden'));
            if (views[viewName]) {
                views[viewName].classList.remove('hidden');
            }
        }
        
        function setStatus(message) {
            statusEl.textContent = message;
        }

        // --- 4. NATIVE IndexedDB HELPERS (Unchanged) ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = window.indexedDB.open(DB_NAME, 1);
                request.onerror = (e) => reject('IndexedDB error: ' + request.error);
                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
                        db.createObjectStore(DB_STORE_NAME, { keyPath: 'key' });
                    }
                };
            });
        }
        function dbGet(key) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readonly');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        function dbPut(value) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readwrite');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.put(value);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        function dbDelete(key) {
             return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readwrite');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // --- 5. NATIVE CRYPTO HELPERS (Unchanged) ---
        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const passwordBuffer = enc.encode(password);
            const baseKey = await window.crypto.subtle.importKey(
                'raw', passwordBuffer, { name: 'PBKDF2' }, false, ['deriveKey']
            );
            return window.crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
                baseKey,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }
        async function encryptToken(plainTextToken, password) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            const enc = new TextEncoder();
            const tokenBuffer = enc.encode(plainTextToken);
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv }, key, tokenBuffer
            );
            return { key: DB_TOKEN_KEY, ciphertext, salt, iv };
        }
        async function decryptToken(password, ciphertext, salt, iv) {
            const key = await deriveKey(password, salt);
            try {
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv }, key, ciphertext
                );
                return new TextDecoder().decode(decryptedBuffer);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid password');
            }
        }
        
        // --- 6. CORE APP LOGIC & EVENT HANDLERS ---
        
        /** Called on page load */
        async function main() {
            try {
                await initDB();
                setStatus('Database initialized.');
                const encryptedData = await dbGet(DB_TOKEN_KEY);
                
                if (encryptedData) {
                    setStatus('Encrypted token found.');
                    showView('unlock');
                } else {
                    setStatus('Ready for setup.');
                    showView('setup');
                }

            } catch (err) {
                setStatus('Initialization Error: ' + err.message);
                console.error(err);
            }
        }
        
        /** Handle password submit to UNLOCK */
        document.getElementById('form-unlock').onsubmit = async (e) => {
            e.preventDefault();
            const password = document.getElementById('unlock-password').value;
            setStatus('Decrypting token...');
            
            try {
                const encryptedData = await dbGet(DB_TOKEN_KEY);
                const token = await decryptToken(
                    password, 
                    encryptedData.ciphertext, 
                    encryptedData.salt, 
                    encryptedData.iv
                );
                
                // Set global state
                sessionAccessToken = token; 
                sessionRepoPath = encryptedData.repoPath; // Load the repo path
                
                setStatus('Session unlocked!');
                showView('loggedin');
                document.getElementById('unlock-password').value = ''; 
                
                // Fetch root repo contents on unlock
                await fetchAndRenderContents('');
                
            } catch (err) {
                setStatus('Unlock failed: Invalid password.');
            }
        };

        /** Handle the initial SETUP form */
        document.getElementById('form-setup').onsubmit = async (e) => {
            e.preventDefault();
            // Get repo path
            const repoPath = document.getElementById('setup-repo').value;
            const token = document.getElementById('setup-token').value;
            const password = document.getElementById('setup-password').value;

            // Validation
            if (!repoPath || !token || !password) {
                alert('Please fill out all fields.');
                return;
            }
            if (repoPath.split('/').length !== 2) {
                 alert('Repo path must be in "owner/repo" format.');
                 return;
            }
            if (!token.startsWith('github_pat_')) {
                 alert('This does not look like a valid Fine-grained Personal Access Token. It should start with "github_pat_".');
                 return;
            }

            setStatus('Encrypting and saving token...');
            try {
                const encryptedData = await encryptToken(token, password);
                
                // Add repo path to the object we save
                encryptedData.repoPath = repoPath;
                
                await dbPut(encryptedData);
                
                // Set global state
                sessionAccessToken = token; 
                sessionRepoPath = repoPath;
                
                setStatus('Token encrypted and saved!');
                showView('loggedin');

                // Fetch root repo contents on setup
                await fetchAndRenderContents('');

            } catch (err) {
                setStatus('Error saving token: ' + err.message);
            }
        };

        /** Handle "Log Out" button click */
        document.getElementById('btn-logout').onclick = async () => {
            if (confirm('This will log you out and permanently delete your encrypted token. You will need to set it up again. Continue?')) {
                setStatus('Logging out...');
                await dbDelete(DB_TOKEN_KEY);
                sessionAccessToken = null;
                sessionRepoPath = null;
                currentPath = '';
                setStatus('Logged out and token cleared.');
                showView('setup');
                fileExplorerEl.innerHTML = ''; // Clear file list
            }
        };
        
        // --- 7. GITHUB API & BROWSER LOGIC ---

        /** Makes an authenticated fetch call to the GitHub API */
        async function githubFetch(path) {
            const url = `https://api.github.com/repos/${sessionRepoPath}/contents/${path}`;
            
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${sessionAccessToken}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('401 Bad Credentials. Your token may be invalid or expired.');
                }
                if (response.status === 404) {
                    throw new Error('404 Not Found. Check your repository path.');
                }
                throw new Error(`API Error: ${response.status}`);
            }
            return response.json();
        }

        /** Fetches content (file or dir) and renders it */
        async function fetchAndRenderContents(path) {
            setStatus('Fetching repository contents...');
            fileExplorerEl.innerHTML = '<li>Loading...</li>';
            fileContentEl.classList.add('hidden'); // Hide file view
            fileExplorerEl.classList.remove('hidden'); // Show list view
            
            try {
                const data = await githubFetch(path);
                currentPath = path; // Update global path
                currentPathEl.textContent = path || '/'; // Update UI
                
                if (Array.isArray(data)) {
                    // It's a directory
                    renderDirectory(data);
                } else if (data.type === 'file') {
                    // It's a file (e.g., if user clicked a file link)
                    renderFile(data);
                }
                setStatus('Ready.');
            } catch (err) {
                setStatus(err.message);
                fileExplorerEl.innerHTML = `<li>Error: ${err.message}</li>`;
            }
        }

        /** Renders a list of files and directories */
        function renderDirectory(items) {
            fileExplorerEl.innerHTML = ''; // Clear "Loading..."
            
            // Sort to show directories first
            items.sort((a, b) => {
                if (a.type === b.type) return a.name.localeCompare(b.name);
                return a.type === 'dir' ? -1 : 1;
            });

            for (const item of items) {
                const li = document.createElement('li');
                const icon = item.type === 'dir' ? 'üìÅ' : 'üìÑ';
                li.innerHTML = `<a href="#">${icon} ${item.name}</a>`;
                
                li.onclick = (e) => {
                    e.preventDefault();
                    fetchAndRenderContents(item.path); // Fetch new path
                };
                fileExplorerEl.appendChild(li);
            }
        }

        /** Renders the content of a single file */
        function renderFile(fileData) {
            fileExplorerEl.classList.add('hidden'); // Hide list
            fileContentEl.classList.remove('hidden'); // Show content

            if (fileData.encoding !== 'base64') {
                fileContentEl.textContent = 'Error: Cannot display this file type (not Base64).';
                return;
            }

            try {
                // Decode Base64 content
                // Use the robust TextDecoder method for UTF-8 safety
                const binaryString = atob(fileData.content);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const decoder = new TextDecoder('utf-8');
                const decodedContent = decoder.decode(bytes);

                fileContentEl.textContent = decodedContent;
            } catch (e) {
                fileContentEl.textContent = 'Error decoding file: ' + e.message;
            }
        }

        /** Handle "Back" button click */
        document.getElementById('btn-back').onclick = () => {
            if (currentPath === '') return; // Already at root
            
            const parts = currentPath.split('/');
            parts.pop(); // Remove last part
            const newPath = parts.join('/');
            
            fetchAndRenderContents(newPath); // Fetch parent
        };


        // --- 8. START THE APP ---
        window.onload = main;
        
    </script>
</body>
</html>
