<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure PWA Auth PoC</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; max-width: 600px; margin: auto; }
        div { margin-bottom: 15px; border: 1px solid #ddd; padding: 15px; border-radius: 8px; }
        input[type="password"], input[type="text"] { width: 95%; padding: 10px; font-size: 16px; margin-bottom: 10px; }
        button { padding: 12px 18px; font-size: 16px; cursor: pointer; background: #0366d6; color: white; border: none; border-radius: 6px; }
        button:hover { background: #0056b3; }
        button.danger { background: #d73a49; }
        button.danger:hover { background: #b02a37; }
        pre { background: #f6f8fa; padding: 15px; border-radius: 6px; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h1>Secure Serverless PWA PoC</h1>
    <p>Status: <b id="status">Initializing...</b></p>

    <div id="view-connect">
        <h3>Connect to GitHub</h3>
        <p>This will start the GitHub OAuth flow to get an access token. This token will then be encrypted with a password you create and stored in your browser's IndexedDB.</p>
        <button id="btn-connect">Connect to GitHub</button>
    </div>

    <div id="view-unlock" class="hidden">
        <h3>Unlock Session</h3>
        <p>Welcome back! Please enter your master password to decrypt your GitHub connection.</p>
        <form id="form-unlock">
            <input type="password" id="unlock-password" placeholder="Your master password" required>
            <button type="submit">Unlock</button>
        </form>
    </div>

    <div id="view-loggedin" class="hidden">
        <h3>Session Unlocked</h3>
        <p>You are authenticated for this session! Your token is loaded in memory.</p>
        <button id="btn-getdata">Test API (Get User Info)</button>
        <button id="btn-logout" class="danger">Log Out & Clear Token</button>
    </div>

    <div id="view-set-password" class="hidden">
        <h3>Create Master Password</h3>
        <p>Success! Your GitHub token has been fetched. Please create a strong master password to encrypt and save it. <strong>If you forget this, you must log out and reconnect.</strong></p>
        <form id="form-set-password">
            <input type="password" id="set-password" placeholder="Create a strong password" required>
            <button type="submit">Save & Encrypt</button>
        </form>
    </div>

    <h3>API Output:</h3>
    <pre id="output">No data fetched yet.</pre>


    <script>
        // --- 1. CONFIGURATION ---
        const GITHUB_CLIENT_ID = 'YOUR_CLIENT_ID_HERE'; // ⚠️ PASTE YOUR CLIENT ID HERE
        const GITHUB_CALLBACK_URL = window.location.origin + window.location.pathname;
        const DB_NAME = 'pwa-secure-db';
        const DB_STORE_NAME = 'settings';
        const DB_TOKEN_KEY = 'github_token_data';
        
        // --- 2. GLOBAL STATE ---
        let db; // Our IndexedDB instance
        let sessionAccessToken = null; // Our IN-MEMORY token for this session
        
        // --- 3. UI HELPERS ---
        const statusEl = document.getElementById('status');
        const outputEl = document.getElementById('output');
        const views = {
            connect: document.getElementById('view-connect'),
            unlock: document.getElementById('view-unlock'),
            loggedin: document.getElementById('view-loggedin'),
            setPassword: document.getElementById('view-set-password')
        };
        
        function showView(viewName) {
            Object.values(views).forEach(v => v.classList.add('hidden'));
            if (views[viewName]) {
                views[viewName].classList.remove('hidden');
            }
        }
        
        function setStatus(message) {
            statusEl.textContent = message;
        }

        // --- 4. NATIVE IndexedDB HELPERS (PROMISE-BASED) ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = window.indexedDB.open(DB_NAME, 1);
                
                request.onerror = (e) => reject('IndexedDB error: ' + request.error);
                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
                        db.createObjectStore(DB_STORE_NAME, { keyPath: 'key' });
                    }
                };
            });
        }
        
        function dbGet(key) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readonly');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        function dbPut(value) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readwrite');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.put(value);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        function dbDelete(key) {
             return new Promise((resolve, reject) => {
                const tx = db.transaction([DB_STORE_NAME], 'readwrite');
                const store = tx.objectStore(DB_STORE_NAME);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // --- 5. NATIVE CRYPTO HELPERS ---

        /** Derives a 256-bit AES-GCM key from a password and salt using PBKDF2 */
        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const passwordBuffer = enc.encode(password);
            const baseKey = await window.crypto.subtle.importKey(
                'raw', passwordBuffer, { name: 'PBKDF2' }, false, ['deriveKey']
            );
            return window.crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
                baseKey,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        /** Encrypts a plaintext token with a password */
        async function encryptToken(plainTextToken, password) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            const enc = new TextEncoder();
            const tokenBuffer = enc.encode(plainTextToken);
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv }, key, tokenBuffer
            );
            
            return {
                key: DB_TOKEN_KEY, // The key for IndexedDB
                ciphertext, // ArrayBuffer
                salt,       // Uint8Array
                iv          // Uint8Array
            };
        }

        /** Decrypts a ciphertext with a password, salt, and iv */
        async function decryptToken(password, ciphertext, salt, iv) {
            const key = await deriveKey(password, salt);
            try {
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv }, key, ciphertext
                );
                return new TextDecoder().decode(decryptedBuffer);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw new Error('Invalid password');
            }
        }
        
        // --- 6. OAUTH PKCE FLOW ---

        /** Generates a PKCE verifier and challenge */
        async function createPkceChallenge() {
            function base64url(buffer) {
                let str = btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
                return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            }
            async function sha256(plain) {
                const encoder = new TextEncoder();
                const data = encoder.encode(plain);
                return window.crypto.subtle.digest('SHA-256', data);
            }
            const verifier = base64url(window.crypto.getRandomValues(new Uint8Array(32)));
            const hashed = await sha256(verifier);
            const challenge = base64url(hashed);
            return { verifier, challenge };
        }

        /** Step 1: Redirect user to GitHub for auth */
        async function redirectToGitHub() {
            if (!GITHUB_CLIENT_ID.startsWith('YOUR_CLIENT_ID')) {
                setStatus('Redirecting to GitHub...');
                const { verifier, challenge } = await createPkceChallenge();
                sessionStorage.setItem('pkce_verifier', verifier); // Store verifier to survive redirect
                
                const params = new URLSearchParams({
                    client_id: GITHUB_CLIENT_ID,
                    redirect_uri: GITHUB_CALLBACK_URL,
                    scope: 'repo', // Request full repo access
                    state: 'pwa-auth-poc-state',
                    code_challenge: challenge,
                    code_challenge_method: 'S256'
                });
                
                window.location.href = `https://github.com/login/oauth/authorize?${params.toString()}`;
            } else {
                alert('ERROR: Please set your GITHUB_CLIENT_ID in the script!');
            }
        }
        
        /** Step 3: Exchange the code for a token (called from handleAuthCallback) */
        async function exchangeCodeForToken(code, verifier) {
            setStatus('Exchanging code for token...');
            
            const response = await fetch('https://github.com/login/oauth/access_token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({
                    client_id: GITHUB_CLIENT_ID,
                    code: code,
                    redirect_uri: GITHUB_CALLBACK_URL,
                    code_verifier: verifier
                })
            });

            if (!response.ok) throw new Error('Failed to exchange token');
            const data = await response.json();
            if (data.error) throw new Error(data.error_description);
            return data.access_token;
        }

        /** Step 2: Handle the redirect back from GitHub */
        async function handleAuthCallback() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');
            
            if (code) {
                setStatus('Auth successful, processing...');
                window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                const verifier = sessionStorage.getItem('pkce_verifier');
                if (!verifier) throw new Error('PKCE Verifier not found');
                
                sessionStorage.removeItem('pkce_verifier');

                try {
                    const plainTextToken = await exchangeCodeForToken(code, verifier);
                    setStatus('Please create a master password.');
                    showView('setPassword');
                    
                    // Add submit handler for the password form
                    document.getElementById('form-set-password').onsubmit = async (e) => {
                        e.preventDefault();
                        setStatus('Encrypting and saving token...');
                        const password = document.getElementById('set-password').value;
                        if (!password) {
                            alert('Password cannot be empty.');
                            return;
                        }
                        
                        const encryptedData = await encryptToken(plainTextToken, password);
                        await dbPut(encryptedData);
                        sessionAccessToken = plainTextToken;
                        
                        setStatus('Logged in and token saved!');
                        showView('loggedin');
                    };

                } catch (err) {
                    setStatus('Error during auth: ' + err.message);
                    outputEl.textContent = err;
                    showView('connect');
                }
                return true; // We handled a callback
            }
            return false; // Not a callback
        }

        // --- 7. CORE APP LOGIC & EVENT HANDLERS ---
        
        /** Called on page load */
        async function main() {
            try {
                await initDB();
                setStatus('Database initialized.');

                const isCallback = await handleAuthCallback();
                if (isCallback) return; // Stop, callback handler will finish

                const encryptedData = await dbGet(DB_TOKEN_KEY);
                
                if (encryptedData) {
                    setStatus('Encrypted token found.');
                    showView('unlock');
                } else {
                    setStatus('Ready to connect.');
                    showView('connect');
                }

            } catch (err) {
                setStatus('Initialization Error: ' + err.message);
                console.error(err);
            }
        }
        
        /** Handle password submit to UNLOCK */
        document.getElementById('form-unlock').onsubmit = async (e) => {
            e.preventDefault();
            const password = document.getElementById('unlock-password').value;
            setStatus('Decrypting token...');
            
            try {
                const encryptedData = await dbGet(DB_TOKEN_KEY);
                const token = await decryptToken(
                    password, 
                    encryptedData.ciphertext, 
                    encryptedData.salt, 
                    encryptedData.iv
                );
                
                sessionAccessToken = token; // SUCCESS! Store in memory.
                setStatus('Session unlocked!');
                showView('loggedin');
                document.getElementById('unlock-password').value = ''; // Clear password field
                
            } catch (err) {
                setStatus('Unlock failed: Invalid password.');
            }
        };

        /** Handle "Connect" button click */
        document.getElementById('btn-connect').onclick = redirectToGitHub;

        /** Handle "Log Out" button click */
        document.getElementById('btn-logout').onclick = async () => {
            if (confirm('This will log you out and permanently delete your encrypted token. You will need to reconnect to GitHub to use the app again. Continue?')) {
                setStatus('Logging out...');
                await dbDelete(DB_TOKEN_KEY);
                sessionAccessToken = null;
                setStatus('Logged out and token cleared.');
                showView('connect');
                outputEl.textContent = 'Logged out.';
            }
        };
        
        /** Handle "Get Data" button click (PROVES THE TOKEN WORKS) */
        document.getElementById('btn-getdata').onclick = async () => {
            if (!sessionAccessToken) {
                alert('Error: No session token. Please unlock.');
                return;
            }
            
            setStatus('Fetching user data from GitHub...');
            outputEl.textContent = 'Loading...';
            
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `Bearer ${sessionAccessToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!response.ok) {
                    // Handle 401 Bad Credentials
                    if (response.status === 401) {
                        outputEl.textContent = 'API Error: 401 Bad Credentials. Your token may have expired or been revoked. Please log out and reconnect.';
                        setStatus('API Error: Bad credentials');
                        return;
                    }
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                outputEl.textContent = JSON.stringify(data, null, 2);
                setStatus('Data fetched successfully!');
                
            } catch (err) {
                setStatus('API Error: ' + err.message);
                outputEl.textContent = err.message;
            }
        };

        // --- 8. START THE APP ---
        window.onload = main;
        
    </script>
</body>
</html>
